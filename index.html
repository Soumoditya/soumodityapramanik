<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interstellar Event Horizon</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- Configuration ---
        const BLACK_HOLE_RADIUS = 0.5;      // Size of the Event Horizon
        const DISK_INNER = 1.2;             // Inner edge of accretion disk
        const DISK_OUTER = 4.5;             // Outer edge of accretion disk
        
        // --- Setup Scene ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Shader Code ---
        const fragmentShader = `
            uniform float iTime;
            uniform vec2 iResolution;
            uniform vec2 iMouse;

            // 3D Noise Function for the accretion disk texture
            float hash(float n) { return fract(sin(n) * 43758.5453123); }
            float noise(vec3 x) {
                vec3 p = floor(x);
                vec3 f = fract(x);
                f = f * f * (3.0 - 2.0 * f);
                float n = p.x + p.y * 57.0 + 113.0 * p.z;
                return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                               mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                           mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                               mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
            }

            // Rotational matrix
            mat3 rotateY(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(c, 0, -s, 0, 1, 0, s, 0, c);
            }

            mat3 rotateX(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(1, 0, 0, 0, c, -s, 0, s, c);
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                // Normalize coordinates
                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
                
                // Camera setup (Mouse controls view angle)
                vec3 ro = vec3(0.0, 0.0, -8.0); // Ray Origin
                vec3 rd = normalize(vec3(uv, 1.5)); // Ray Direction
                
                // Mouse rotation
                float rotX = (iMouse.y / iResolution.y - 0.5) * 3.0;
                float rotY = (iMouse.x / iResolution.x - 0.5) * 6.0;
                mat3 viewMat = rotateY(rotY + 0.5) * rotateX(rotX + 0.2); // +offsets for initial nice angle
                ro = viewMat * ro;
                rd = viewMat * rd;

                vec3 col = vec3(0.0);
                
                // --- Raymarching / Gravitational Lensing Physics ---
                
                float bhRadius = ${BLACK_HOLE_RADIUS};
                float diskInner = ${DISK_INNER};
                float diskOuter = ${DISK_OUTER};
                
                vec3 p = ro;
                float dist = 0.0;
                float totDist = 0.0;
                
                // Accumulate glow
                vec3 glow = vec3(0.0);
                
                // Step size for raymarching
                for(int i = 0; i < 150; i++) {
                    float r = length(p); // Distance from black hole center (0,0,0)
                    
                    // Event Horizon check
                    if(r < bhRadius) {
                        col = vec3(0.0); // Absolute black
                        break; 
                    }
                    
                    // Gravity bending (Simplified approximation of General Relativity)
                    // Light bends towards the mass (0,0,0)
                    vec3 gravity = -normalize(p) * (0.08 / (r * r)); 
                    rd += gravity * 0.1; // Apply bending
                    rd = normalize(rd);
                    
                    p += rd * 0.15; // Move ray forward
                    totDist += 0.15;
                    
                    if(totDist > 20.0) break; // Too far away
                    
                    // --- Accretion Disk Rendering ---
                    // Check if we are near the disk plane (y ~= 0) and within radius
                    float diskH = 0.1; // Disk thickness
                    
                    // Smooth distance to disk plane
                    float distToPlane = abs(p.y);
                    
                    if(distToPlane < diskH && r > diskInner && r < diskOuter) {
                        // Calculate disk coordinates for texture
                        float angle = atan(p.z, p.x);
                        float speed = 2.0 / r; // Inner parts move faster
                        
                        // Noise texture
                        float noiseVal = noise(vec3(p.x * 3.0, p.z * 3.0, iTime * speed + angle * 2.0));
                        noiseVal += noise(vec3(p.x * 10.0, p.z * 10.0, iTime * speed * 2.0));
                        
                        // Intensity gradient (brighter inner, darker outer)
                        float intensity = exp(-(r - diskInner) * 2.0);
                        
                        // Doppler shift simulation (redshift/blueshift based on rotation)
                        // Simple dot product of view dir and tangent
                        vec3 tangent = normalize(cross(vec3(0,1,0), p));
                        float doppler = dot(rd, tangent);
                        vec3 diskCol = vec3(1.0, 0.6, 0.2); // Base orange
                        
                        // Apply Doppler: Blue on approach (left), Red on recede (right)
                        diskCol = mix(diskCol, vec3(0.5, 0.8, 1.0), clamp(doppler * 0.5, 0.0, 1.0)); // Blue shift
                        diskCol *= (1.0 - abs(doppler) * 0.3); // Dimming

                        // Accumulate color (Volumetric addition)
                        float alpha = (1.0 - smoothstep(0.0, diskH, distToPlane)) * 0.15;
                        glow += diskCol * noiseVal * intensity * alpha * 5.0;
                    }
                }
                
                // Add starfield background if ray didn't hit black hole
                if (length(col) == 0.0 && length(glow) < 1.0) {
                     float stars = pow(hash(dot(rd, vec3(12.9898, 78.233, 45.5432))), 100.0) * 1.5;
                     col += vec3(stars);
                }

                fragColor = vec4(col + glow, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        const vertexShader = `
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        `;

        // --- Init Three.js Material ---
        const material = new THREE.ShaderMaterial({
            fragmentShader,
            vertexShader,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2() },
                iMouse: { value: new THREE.Vector2() }
            }
        });

        const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(plane);

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });

        // Initial set
        material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        
        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            material.uniforms.iMouse.value.x = e.clientX;
            material.uniforms.iMouse.value.y = window.innerHeight - e.clientY;
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.iTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
